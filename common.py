import asyncio
from datetime import datetime, timedelta
import functools
import traceback
from typing import List, Set
from aiogram import Bot, Router
from aiogram.types import Message, CallbackQuery
from aiogram.exceptions import TelegramAPIError, TelegramBadRequest

from peewee import fn, Case, JOIN

from filters import IsBloger, IsReviewer
from models import *


router = Router()


@router.callback_query()
async def other_callback(callback: CallbackQuery):
    await callback.message.answer(
        text='–í—ã —Å–æ–≤–µ—Ä—à–∏–ª–∏ –Ω–µ–∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É'
    )
    user = User.get_or_none(tg_id=callback.from_user.id)
    await send_message_admins(
        bot=callback.bot,
        text=f"other_callback {user.comment}\n{callback.message.text}\n{callback.data}"
    )


@router.message()
async def other_message(message: Message):
    await message.answer(
        text='–í—ã —Å–æ–≤–µ—Ä—à–∏–ª–∏ –Ω–µ–∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É'
    )
    user = User.get_or_none(tg_id=message.from_user.id)
    await send_message_admins(
        bot=message.bot,
        text=f"other_message {user.comment}\n{message.text}"
    )


def get_id(text):
    return int(text[(text.rfind('_')+1):])


async def get_user(bot: Bot, tg_id: int) -> User:
    user = User.get_or_none(tg_id=tg_id)
    if user is None:
        await bot.send_message(
            chat_id=tg_id,
            text='–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É /start'
        )
    return user


def get_date_time(hours: int = 0):
    due_date = datetime.now()
    due_date = datetime(
        year=due_date.year,
        month=due_date.month,
        day=due_date.day,
        hour=due_date.hour,
    )
    due_date += timedelta(
        hours=hours
    )
    return due_date


def error_handler():
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –≤ —Ö—ç–Ω–¥–ª–µ—Ä–∞—Ö –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–¥–º–∏–Ω—É"""
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                traceback.print_exc()
                if len(args) == 0:
                    return None
                bot: Bot = None
                message: Message = None
                if isinstance(args[0], Message) or isinstance(args[0], CallbackQuery):
                    bot = args[0].bot
                    message = args[0]
                elif isinstance(args[0], Bot):
                    bot = args[0]

                if bot is None:
                    return None

                error_text = (f'üö®{traceback.format_exc()}')
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω—É
                try:
                    await send_message_admins(
                        bot=bot,
                        text=error_text
                    )
                except TelegramAPIError:
                    print("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω—É.")

                if message:
                    await message.answer(
                        text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —É–∂–µ —É–≤–µ–¥–æ–º–ª—ë–Ω."
                    )
        return wrapper
    return decorator


@error_handler()
async def send_task(bot: Bot):
    '''–í—ã–¥–∞—Ç—å –∑–∞–¥–∞—á—É –±–ª–æ–≥–µ—Ä—É'''

    # –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –≤–µ–¥—É—Ç—Å—è —Ä–∞–±–æ—Ç—ã
    tasks: Set[Task] = set(
        Task
        .select(Task)
        .where(Task.status.in_([0, 1]))
    )

    # —É–±—Ä–∞—Ç—å –±–ª–æ–≥–µ—Ä–æ–≤ —É –∫–æ—Ç–æ—Ä—ã—Ö –∏–¥–µ—Ç —Ä–∞–±–æ—Ç–∞ –Ω–∞–¥ –∑–∞–¥–∞—á–µ–π
    blogers -= {
        task.implementer for task in
        Task
        .select(Task.implementer)
        .where(Task.status.in_([0, 1]))
    }

    # –°–ø–∏—Å–æ–∫ –∫—É—Ä—Å–æ–≤
    courses: Set[Course] = set(Course.select())

    # –°–≤–æ–±–æ–¥–Ω—ã–µ –∫—É—Ä—Å—ã: —É–±–∏—Ä–∞–µ–º –∫—É—Ä—Å—ã –ø–æ –∫–æ—Ç–æ—Ä—ã–º –≤–µ–¥—É—Ç—Å—è —Ä–∞–±–æ—Ç—ã
    courses -= {task.theme.course for task in tasks}
    course_ids = [course.id for course in courses]

    # –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö —Ä–µ–π—Ç–∏–Ω–≥–∞
    blogers: List[User] = sorted(
        blogers, key=lambda user: user.bloger_rating, reverse=True)

    # –û—Ç–±–∏—Ä–∞–µ–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –±–ª–æ–≥–µ—Ä–∞ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∫—É—Ä—Å
    for bloger in blogers:

        # –°–ø–∏—Å–æ–∫ –∫—É—Ä—Å–æ–≤ –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥–ø–∏—Å–∞–Ω –±–ª–æ–≥–µ—Ä
        courses_by_bloger: Set[UserCourse] = {
            user_course.course for user_course in
            UserCourse
            .select()
            .where(
                (UserCourse.user == bloger.id) &
                (UserCourse.course.in_(course_ids))
            )
        }

        # –ï—Å–ª–∏ —É –±–ª–æ–≥–µ—Ä–∞ –Ω–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫, —Ç–æ —Ñ–∏–≥ –µ–º—É, –∞ –Ω–µ –∑–∞–¥–∞—á—É
        if len(courses_by_bloger) == 0:
            continue

        # –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∫—É—Ä—Å–æ–≤ –∏ —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤ –±–ª–æ–≥–µ—Ä–∞
        courses_by_bloger &= courses

        # –ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∫—É—Ä—Å–æ–≤ –¥–ª—è –±–ª–æ–≥–µ—Ä–∞, –Ω–µ —Ñ–∞—Ä—Ç–∞–Ω—É–ª–æ
        if len(courses_by_bloger) == 0:
            continue

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫—É—Ä—Å—ã –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è —Å—Ä–µ–¥–Ω–µ–π –æ—Ü–µ–Ω–∫–∏
        courses_by_bloger = sorted(
            courses_by_bloger,
            key=lambda course: (
                Task
                .select(fn.AVG(Task.score))
                .join(Theme)
                .where(
                    (Theme.course == course.id) &
                    (Task.implementer == bloger.id)
                )
                .scalar() or 0.8
            ),
            reverse=True
        )

        # –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∫—É—Ä—Å –¥–ª—è –±–ª–æ–≥–µ—Ä–∞
        course_by_bloger: Course = courses_by_bloger[0]

        # –°–ø–∏—Å–æ–∫ —Ç–µ–º —ç—Ç–æ–≥–æ –∫—É—Ä—Å–∞
        themes: Set[Theme] = set(Theme.select().where(
            Theme.course == course_by_bloger.id))

        # –£–±–∏—Ä–∞–µ–º –∏–∑ —Å–ø–∏—Å–∫–∞ —Ç–µ–º—ã, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –≤–µ–¥—É—Ç—Å—è –∏–ª–∏ —É–¥–∞—á–Ω–æ –∑–∞–∫–æ–Ω—á–µ–Ω—ã —Ä–∞–±–æ—Ç—ã
        themes -= {
            theme for theme in
            Theme
            .select()
            .join(Task)
            .where(
                (Task.status >= 0) &
                (Theme.course == course_by_bloger.id)
            )
        }

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ç—ã–º–µ –ø–æ ID
        themes: List[Theme] = sorted(themes, key=lambda theme: theme.id)

        # –¢–µ–º–∞ –¥–ª—è –±–ª–æ–≥–µ—Ä–∞
        theme_by_bloger: Theme = themes[0]

        hours = int(theme_by_bloger.complexity * 72 + 1)
        if hours < 72:
            hours = 72

        task_by_bloger: Task = Task.create(
            implementer=bloger,
            theme=theme_by_bloger,
            due_date=get_date_time(hours=hours)
        )

        try:
            await bot.send_message(
                chat_id=bloger.tg_id,
                text=f'–í–∞–º –≤—ã–¥–∞–Ω–∞ —Ç–µ–º–∞ {theme_by_bloger.link}.\n'
                f'–°—Ä–æ–∫: {task_by_bloger.due_date}\n'
                '<a href="https://docs.google.com/document/d/1KVv9BAqtZ1FZzqUTWO9REbTWJoT3LQrZfVHHtoAQWQ0/edit?usp=sharing">–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –≤–∏–¥–µ–æ</a>',
                parse_mode='HTML'
            )
        except TelegramBadRequest as ex:
            await send_message_admins(
                bot=bot,
                text=str(ex)
            )

        await send_message_admins(
            bot=bot,
            text=f'–ë–ª–æ–≥–µ—Ä—É {bloger.link} –≤—ã–¥–∞–Ω–∞ —Ç–µ–º–∞ {theme_by_bloger.link}',
        )


@error_handler()
async def send_message_admins(bot: Bot, text: str, reply_markup=None):
    for admin in get_admins():
        try:
            await bot.send_message(
                chat_id=admin.tg_id,
                text=text,
                parse_mode='HTML',
                disable_web_page_preview=True,
                reply_markup=reply_markup,
            )
        except Exception as ex:
            print(ex)
            await bot.send_message(
                chat_id=admin.tg_id,
                text=text,
                reply_markup=reply_markup,
            )


def get_admins() -> List[User]:
    return (
        User
        .select(User)
        .join(UserRole)
        .where(UserRole.role == Role.get(name='–ê–¥–º–∏–Ω').id)
    )


@error_handler()
async def send_new_review_request(bot: Bot):
    """–í—ã–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É"""

    # –≤–∏–¥–µ–æ —É –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä—è—é—â–∏—Ö
    video_ids = [v.id for v in
                 Video
                 .select(Video)
                 .join(ReviewRequest, JOIN.LEFT_OUTER, on=(ReviewRequest.video == Video.id))
                 .join(Task, on=(Task.id == Video.task))
                 .join(User, on=(User.id == Task.implementer))
                 .where(
                     (Task.status == 1) &
                     ((ReviewRequest.status >= 0) |
                      (ReviewRequest.status.is_null()))
                 )
                 .group_by(Video.id)
                 .order_by(User.bloger_rating.desc())
                 .having(fn.COUNT(Video.id) < 5)
                 ]
    if video_ids:
        video_id = video_ids[0]
        if await add_reviewer(bot, Video.get_by_id(video_id)):
            await send_new_review_request(bot)


@error_handler()
async def add_reviewer(bot: Bot, video_id: int):
    """–ù–∞–∑–Ω–∞—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä—è—é—â–µ–≥–æ –Ω–∞ –≤–∏–¥–µ–æ"""

    # –°–≤–æ–±–æ–¥–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä—è—é—â–∏–µ
    vacant_reviewer_ids: List[int] = get_vacant_reviewer_ids()

    video: Video = Video.get_by_id(video_id)
    task: Task = video.task
    theme: Theme = task.theme

    if task.implementer_id in vacant_reviewer_ids:
        vacant_reviewer_ids.remove(task.implementer_id)

    if len(vacant_reviewer_ids) == 0:
        await send_message_admins(
            bot=bot,
            text=(
                f'<b>–ó–∞–∫–æ–Ω—á–∏–ª–∏—Å—å c–≤–æ–±–æ–¥–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä—è—é—â–∏–µ</b>'
                f'{theme.course.title}|{theme.link}'
            )
        )
        return False

    # —Ç–µ, –∫—Ç–æ —É–∂–µ –ø—Ä–æ–≤–µ—Ä—è–ª–∏ —ç—Ç—É —Ç–µ–º—É
    reviewer_ids = [rr.reviewer_id for rr in
                    ReviewRequest
                    .select(ReviewRequest.reviewer)
                    .join(Video, on=(Video.id == ReviewRequest.video))
                    .join(Task, on=(Task.id == Video.task))
                    .where(Task.theme == video.task.theme_id)
                    .group_by(ReviewRequest.reviewer)
                    ]

    candidat_reviewer_ids = [
        i for i in vacant_reviewer_ids if i not in reviewer_ids]
    if len(candidat_reviewer_ids) == 0:

        theme = Video.get_by_id(video_id).task.theme
        await send_message_admins(
            bot=bot,
            text=(
                f'<b>–ù–µ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ —Å—Ä–µ–¥–∏ —Å–≤–æ–±–æ–¥–Ω—ã—Ö –ø—Ä–æ–≤–µ—Ä—è—é—â–∏—Ö</b>'
                f'{theme.course.title}|{theme.link}'
            )
        )
        return False

    due_date = get_date_time(hours=25)
    review_request = ReviewRequest.create(
        reviewer_id=candidat_reviewer_ids[0],
        video_id=video_id,
        due_date=due_date
    )
    await send_video(bot, review_request)
    return True


@error_handler()
async def send_video(bot: Bot, review_request: ReviewRequest):

    text = f'–í–∞—à–µ –≤–∏–¥–µ–æ –Ω–∞ —Ç–µ–º—É "{review_request.video.task.theme.link}" –≤—ã–¥–∞–Ω–æ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É'
    try:
        await bot.send_message(
            chat_id=review_request.video.task.implementer.tg_id,
            text=text,
            parse_mode='HTML',
            disable_web_page_preview=True,
        )
    except TelegramBadRequest as ex:
        print(ex, text)

    caption = (
        f'–≠—Ç–æ –≤–∏–¥–µ–æ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ {review_request.due_date}.\n'
        f'–¢–µ–º–∞: "{review_request.video.task.theme.course.title}|{review_request.video.task.theme.link}"\n'
        '–î–ª—è –æ—Ü–µ–Ω–∫–∏ –≤–∏–¥–µ–æ –Ω–∞–ø–∏—à–∏—Ç–µ –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ '
        '–≤ –Ω–∞—á–∞–ª–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥–µ—Ç –æ—Ü–µ–Ω–∫–∞ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [0.0; 5.0], –∞ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –æ—Ç–∑—ã–≤ –æ –≤–∏–¥–µ–æ\n'
        '''
0 - –ú–µ–ª–∫–∏–π —Ç–µ–∫—Å—Ç (–∫–∞—á–µ—Å—Ç–≤–æ –≤–∏–¥–µ–æ) –∏ –ø–ª–æ—Ö–æ–π –∑–≤—É–∫. –¢–∞–∫–æ–µ –ª—É—á—à–µ –Ω–∏–∫–æ–º—É –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å
1 - –ú–µ–ª–∫–∏–π —Ç–µ–∫—Å—Ç (–∫–∞—á–µ—Å—Ç–≤–æ –≤–∏–¥–µ–æ) –∏–ª–∏ –Ω–µ—Ä–∞–∑–±–æ—Ä—á–∏–≤—ã–π –∑–≤—É–∫. –†–∞—Å—Å–∫–∞–∑—á–∏–∫–∞ —Ç—è–∂–µ–ª–æ —Å–ª—É—à–∞—Ç—å, –∞ –º–∞—Ç–µ—Ä–∏–∞–ª –Ω–µ –≤–æ—Å–ø—Ä–∏–Ω–∏–º–∞–µ—Ç—Å—è.
2 - –ú–∞—Å—à—Ç–∞–± –∏–ª–∏ –≥—Ä–æ–º–∫–æ—Å—Ç—å (–∫–∞—á–µ—Å—Ç–≤–æ –∑–≤—É–∫–∞) –º–æ–∂–Ω–æ –±—ã–ª–æ —Å–¥–µ–ª–∞—Ç—å —á—É—Ç—å –ø–æ –ª—É—á—à–µ. –ë—ã–ª–æ –æ—á–µ–Ω—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ, –Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ–ø–æ–Ω—è—Ç–Ω–æ.
3 - –ó–≤—É–∫ –∏ –≤–∏–¥–µ–æ –≤ –ø–æ—Ä—è–¥–∫–µ. –ú–∞—Ç–µ—Ä–∏–∞–ª –ø–æ–Ω—è—Ç –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω—É, –µ—Å—Ç—å –Ω–µ—Ä–∞—Å–∫—Ä—ã—Ç—ã–µ –º–µ—Å—Ç–∞ –æ—Ç–Ω–æ—Å—è—â–∏–µ—Å—è –∫ —Ç–µ–º–µ –º–∞—Ç–µ—Ä–∏–∞–ª–∞.
4 - –ó–≤—É–∫ –∏ –≤–∏–¥–µ–æ –≤ –ø–æ—Ä—è–¥–∫–µ. –ú–∞—Ç–µ—Ä–∏–∞–ª –ø–æ–¥–∞–≤–∞–ª—Å—è –Ω–µ—É–≤–µ—Ä–µ–Ω–Ω–æ, –Ω–æ –≤—Å—ë –±—ã–ª–æ –ø–æ–Ω—è—Ç–æ. 
5 - –≠—Ç–æ —Ç–æ—á–Ω–æ –¥–µ–ª–∞–ª –Ω–µ —Å—Ç—É–¥–µ–Ω—Ç, –∞ –∫–∞–∫–æ–π-—Ç–æ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª. –û–±—Ä–∞–∑—Ü–æ–≤–æ–µ –≤–∏–¥–µ–æ.'''
    )
    try:
        await bot.send_video(
            chat_id=review_request.reviewer.tg_id,
            video=review_request.video.file_id,
            caption=caption,
            parse_mode='HTML',
        )
    except TelegramBadRequest as ex:
        print(ex, caption, sep='\n')

    await send_message_admins(
        bot=bot,
        text=f'''<b>–ü—Ä–æ–≤–µ—Ä—è—é—â–∏–π –ø–æ–ª—É—á–∏–ª –≤–∏–¥–µ–æ</b>
–ü—Ä–æ–≤–µ—Ä—è—é—â–∏–π: {review_request.reviewer.comment}
–ë–ª–æ–≥–µ—Ä: {review_request.video.task.implementer.comment}
–ö—É—Ä—Å: {review_request.video.task.theme.course.title}
–¢–µ–º–∞: {review_request.video.task.theme.title}'''
    )


def get_limit_score():
    data = [
        t.score for t in
        Task
        .select(Task.score)
        .where(Task.status.not_in([0, 1, -1]))
        .order_by(Task.id.desc())
        .limit(100)
    ]
    return sum(data)/len(data)


def update_task_score(task: Task) -> Task:

    task_scores = [review.score for review in
                   Review
                   .select(Review)
                   .join(ReviewRequest)
                   .join(Video)
                   .join(Task)
                   .where(Task.id == task.id)
                   ]

    if len(task_scores) == 0:
        return task

    task_score = sum(task_scores) / len(task_scores) / 5

    task.score = task_score
    task.status = 2 if task_score >= get_limit_score() else -2
    task.save()

    return task


def get_vacant_reviewer_ids() -> List[User]:
    reviewer_ids = get_reviewer_ids()
    # –ø—Ä–æ–≤–µ—Ä—è—é—â–∏–µ —É –∫–æ—Ç–æ—Ä—ã—Ö –µ—Å—Ç—å —á—Ç–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
    jobs_ids = [u.id for u in
                User
                 .select(User)
                .join(ReviewRequest)
                .where(
                     (ReviewRequest.status == 0)
                 )
                .group_by(ReviewRequest.reviewer)
                .order_by(User.reviewer_rating.desc())
                ]
    return [i for i in reviewer_ids if i not in jobs_ids]


def get_reviewer_ids() -> List[User]:
    """–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å —Ä–æ–ª—å—é –ø—Ä–æ–≤–µ—Ä—è—é—â–∏–π"""
    return [u.id for u in
            User
             .select(User)
             .join(UserRole)
             .join(Role)
            .where(Role.name == '–ü—Ä–æ–≤–µ—Ä—è—é—â–∏–π')
             .order_by(User.reviewer_rating.desc())
            ]


if __name__ == '__main__':
    data = [
        t.score for t in
        Task
        .select(Task.score)
        .where(Task.status.not_in([0, 1, -1]))
        .order_by(Task.id.desc())
        .limit(100)
    ]
    print(sum(data)/len(data))
